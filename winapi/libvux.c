#include <math.h>
#include <memory.h>

#include "libvux.h"

void Vu0ResetMatrix(VU_MATRIX* m)
{
	memset(m->m, 0, sizeof(m->m));
	m->m[0][0] = 1.0f;
	m->m[1][1] = 1.0f;
	m->m[2][2] = 1.0f;
	m->m[3][3] = 1.0f;
}

void Vu0ApplyMatrix(VU_MATRIX* m, VU_VECTOR* v0, VU_VECTOR* o)
{
	VU_VECTOR out;
	out.x = m->m[0][0] * v0->x + m->m[1][0] * v0->y + m->m[2][0] * v0->z + m->m[3][0] * v0->w;
	out.y = m->m[0][1] * v0->x + m->m[1][1] * v0->y + m->m[2][1] * v0->z + m->m[3][1] * v0->w;
	out.z = m->m[0][2] * v0->x + m->m[1][2] * v0->y + m->m[2][2] * v0->z + m->m[3][2] * v0->w;
	out.w = m->m[0][3] * v0->x + m->m[1][3] * v0->y + m->m[2][3] * v0->z + m->m[3][3] * v0->w;

	//out.x = m->m[0][0] * v0->x + m->m[0][1] * v0->y + m->m[0][2] * v0->z + m->m[0][3] * v0->w;
	//out.y = m->m[1][0] * v0->x + m->m[1][1] * v0->y + m->m[1][2] * v0->z + m->m[1][3] * v0->w;
	//out.z = m->m[2][0] * v0->x + m->m[2][1] * v0->y + m->m[2][2] * v0->z + m->m[2][3] * v0->w;
	//out.w = m->m[3][0] * v0->x + m->m[3][1] * v0->y + m->m[3][2] * v0->z + m->m[3][3] * v0->w;

	//out.x /= out.w;
	//out.y /= out.w;
	//out.z /= out.w;
	//out.w /= out.w;
	*o = out;
}

void Vu0TransposeMatrix(VU_MATRIX* m, VU_MATRIX* out)
{
	VU_MATRIX o;
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			o.m[j][i] = m->m[i][j];
		}
	}
	*out = o;
}

void Vu0MulMatrix(VU_MATRIX* m0, VU_MATRIX* m1, VU_MATRIX* out)
{
	VU_MATRIX o;

	o.m[0][0] = m0->m[0][0] * m1->m[0][0] + m0->m[0][1] * m1->m[1][0] + m0->m[0][2] * m1->m[2][0] + m0->m[0][3] * m1->m[3][0];
	o.m[0][1] = m0->m[0][0] * m1->m[0][1] + m0->m[0][1] * m1->m[1][1] + m0->m[0][2] * m1->m[2][1] + m0->m[0][3] * m1->m[3][1];
	o.m[0][2] = m0->m[0][0] * m1->m[0][2] + m0->m[0][1] * m1->m[1][2] + m0->m[0][2] * m1->m[2][2] + m0->m[0][3] * m1->m[3][2];
	o.m[0][3] = m0->m[0][0] * m1->m[0][3] + m0->m[0][1] * m1->m[1][3] + m0->m[0][2] * m1->m[2][3] + m0->m[0][3] * m1->m[3][3];

	o.m[1][0] = m0->m[1][0] * m1->m[0][0] + m0->m[1][1] * m1->m[1][0] + m0->m[1][2] * m1->m[2][0] + m0->m[1][3] * m1->m[3][0];
	o.m[1][1] = m0->m[1][0] * m1->m[0][1] + m0->m[1][1] * m1->m[1][1] + m0->m[1][2] * m1->m[2][1] + m0->m[1][3] * m1->m[3][1];
	o.m[1][2] = m0->m[1][0] * m1->m[0][2] + m0->m[1][1] * m1->m[1][2] + m0->m[1][2] * m1->m[2][2] + m0->m[1][3] * m1->m[3][2];
	o.m[1][3] = m0->m[1][0] * m1->m[0][3] + m0->m[1][1] * m1->m[1][3] + m0->m[1][2] * m1->m[2][3] + m0->m[1][3] * m1->m[3][3];

	o.m[2][0] = m0->m[2][0] * m1->m[0][0] + m0->m[2][1] * m1->m[1][0] + m0->m[2][2] * m1->m[2][0] + m0->m[2][3] * m1->m[3][0];
	o.m[2][1] = m0->m[2][0] * m1->m[0][1] + m0->m[2][1] * m1->m[1][1] + m0->m[2][2] * m1->m[2][1] + m0->m[2][3] * m1->m[3][1];
	o.m[2][2] = m0->m[2][0] * m1->m[0][2] + m0->m[2][1] * m1->m[1][2] + m0->m[2][2] * m1->m[2][2] + m0->m[2][3] * m1->m[3][2];
	o.m[2][3] = m0->m[2][0] * m1->m[0][3] + m0->m[2][1] * m1->m[1][3] + m0->m[2][2] * m1->m[2][3] + m0->m[2][3] * m1->m[3][3];

	o.m[3][0] = m0->m[3][0] * m1->m[0][0] + m0->m[3][1] * m1->m[1][0] + m0->m[3][2] * m1->m[2][0] + m0->m[3][3] * m1->m[3][0];
	o.m[3][1] = m0->m[3][0] * m1->m[0][1] + m0->m[3][1] * m1->m[1][1] + m0->m[3][2] * m1->m[2][1] + m0->m[3][3] * m1->m[3][1];
	o.m[3][2] = m0->m[3][0] * m1->m[0][2] + m0->m[3][1] * m1->m[1][2] + m0->m[3][2] * m1->m[2][2] + m0->m[3][3] * m1->m[3][2];
	o.m[3][3] = m0->m[3][0] * m1->m[0][3] + m0->m[3][1] * m1->m[1][3] + m0->m[3][2] * m1->m[2][3] + m0->m[3][3] * m1->m[3][3];

	*out = o;
}

void Vu0CopyMatrix(VU_MATRIX* dest, VU_MATRIX* src)
{
	*dest = *src;
}

void VuxRotMatrixZ(VU_MATRIX* m, float z)
{
	float cs, sn;

	cs = cosf(z);
	sn = sinf(z);

	m->m[0][0] = cs;
	m->m[0][1] = sn;
	m->m[1][0] = -sn;
	m->m[1][1] = cs;

	/* colum major(left hand)
	m->m[0][0] = cs;
	m->m[0][1] = -sn;
	m->m[1][0] = sn;
	m->m[1][1] = cs;
	*/
}
